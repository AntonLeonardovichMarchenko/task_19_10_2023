Тестирование с помощью pytest в python
Тестирование — это процесс проверки программного обеспечения на наличие ошибок
и соответствие требованиям (каким таким требованиям ?).
Оно играет важную роль в процессе разработки ПО. Проход тестов гарантирует,
что программный продукт работает правильно и надёжно (???).

Юнит-тестирование:
Сосредоточено на тестировании отдельных "юнитов" или компонентов программного обеспечения независимо
друг от друга.
Цель: убедиться, что каждый отдельный компонент функционирует правильно.
Пример: Если у имеется функция, которая складывает два числа, юнит-тест будет проверять, правильно
ли она это делает для разных наборов входных данных.

Интеграционное тестирование:
Тестирует взаимодействие между двумя или более компонентами или модулями.
Цель: убедиться, что разные части программы работают вместе, как это задумано.
Пример: Если одна функция принимает результаты другой функции как входные данные,
интеграционный тест проверит, работают ли эти функции корректно вместе.
Интеграционные тесты помогают проверить, что система в целом работает без сбоев.

Юнит-тестирование и интеграционное тестирование
В идеале, система должна иметь как юнит-тесты, так и интеграционные тесты.
Юнит-тесты обычно пишутся раньше и помогают обеспечивать корректность основных функций.
Интеграционное тестирование позволяет обеспечить корректное взаимодействие юнитов


Желательно разделять программу на различные подпрограммы (ввод/обработка/вывод) независимо
от её сложности, так как по мере своего развития её код может вырасти и усложниться.
В коде ошибка. Но пока - запуск с ошибочной функцией.

# исходный код в модуле example.py
from math import sqrt

def square_eq_solver(a, b, c):
   result = []
   discriminant = b * b - 4 * a * c

   if discriminant == 0:
       result.append(-b / (2 * a))
   else:
       # дискриминант может быть и НЕ равен 0, но здесь он может быть ОТРИЦАТЕЛЬНЫМ!
       result.append((-b + sqrt(discriminant)) / (2 * a))
       result.append((-b - sqrt(discriminant)) / (2 * a))

   return result

def show_result(data):
   if len(data) > 0:
       for index, value in enumerate(data):
           print(f'Корень номер {index+1} равен {value:.02f}')
   else:
       print('Уравнение с заданными параметрами не имеет корней')

def main():
   a, b, c = map(int, input('нужно ввести три числа через пробел: ').split())
   result = square_eq_solver(a, b, c)
   show_result(result)

if __name__ == '__main__':
   main()

Возможно, что в простом коде ошибку можно заметить при его простом прочтении.
и исправить:

def square_eq_solver(a, b, c):
   result = []
   discriminant = b * b - 4 * a * c

   if discriminant == 0:
       result.append(-b / (2 * a))
   elif discriminant > 0:
       # дискриминант может быть и НЕ равен 0, но он НЕ может быть ОТРИЦАТЕЛЬНЫМ!
       result.append((-b + sqrt(discriminant)) / (2 * a))
       result.append((-b - sqrt(discriminant)) / (2 * a))

   return result

Однако она может быть скрыта в коде настолько глубоко, что её бывает не так просто обнаружить.
В таком случае единственный способ её обнаружить — это протестировать код.

Способ выявления ошибки в данном примере (хорошо, что это простая программа!)

— зная алгоритм нахождения корней уравнения, определить наборы входных данных, которые
  будут переданы на вход программе;
— зная входные данные, можно вручную просчитать, какой ответ должна дать программа;
— запустить программу и передать ей на вход исходные данные;
— получить от нее ответ и сравнивить с тем, который должен быть получен. Если они совпадают —
  хорошо! Перейти к следующему набору данных, если нет, сообщить об ошибке.

Например, для данной задачи можно подобрать следующие тесты:

10x**2 = 0 — единственный корень x=0
2x**2 + 5x — 3 = 0 — у такого уравнения два корня (x1 = 0.5, x2=-3)
10x**2+2 = 0 — у этого уравнения корней нет

Далее программа запускается с тремя наборами значений:
(10 0 0)
(2 5 -3)
(10 0 2)
И в третьем тесте (на третьем наборе) происходит ошибка - возбуждается исключение.
Как раз та, которую можно было заметить в исходном коде программы — не обрабатывался
случай с дискриминантом, меньшем нуля. Для исправления ошибки нужно подкорректировать
код функции так, чтобы этот вариант обрабатывался правильно (заменить её уже
представленным вариантом):

# исправленный исходный код в модуле example.py
from math import sqrt

def square_eq_solver(a, b, c):
   result = []
   discriminant = b * b - 4 * a * c

   if discriminant == 0:
       result.append(-b / (2 * a))
   elif discriminant > 0:
       # дискриминант может быть и НЕ равен 0, но здесь он может быть ОТРИЦАТЕЛЬНЫМ!
       result.append((-b + sqrt(discriminant)) / (2 * a))
       result.append((-b - sqrt(discriminant)) / (2 * a))

   return result

def show_result(data):
   if len(data) > 0:
       for index, value in enumerate(data):
           print(f'Корень номер {index+1} равен {value:.02f}')
   else:
       print('Уравнение с заданными параметрами не имеет корней')

def main():
   a, b, c = map(int, input('нужно ввсти три числа через пробел: ').split())
   result = square_eq_solver(a, b, c)
   show_result(result)

if __name__ == '__main__':
   main()

Концепция автоматического тестирования
Автоматическое тестирование — это процесс выполнения тестов без непосредственного участия
программиста. Вместо того чтобы вручную запускать тесты и проверять их результаты,
автоматические тесты запускаются программой или специальным инструментом.
Программа автоматического тестирования запускается на основе заранее заготовленных входных/выходных
ДАННЫХ и ПРОГРАММЫ, которая будет их вызывать. По сути, это программа, тестирующая другие программы.
И в рамках экосистемы (это типа интерпрепатра !!!) языка python есть несколько пакетов,
позволяющих автоматизировать процесс тестирования.

= Быстрота: Автоматические тесты выполняются гораздо быстрее ручных.
= Повторяемость: Тесты могут быть выполнены столько раз, сколько потребуется, с
  постоянной надежностью.
= Сокращение возможных ошибок: Уменьшается риск человеческой ошибки.
= Широкое покрытие: Способность быстро тестировать большое количество сценариев.

unittest и pytest
Две самые популярные библиотеки — unittest и pytest. Каждая из них имеет свой синтаксис.

unittest: библиотека по умолчанию встроена в стандартную библиотеку языка Python.
По формат для написания тестов:

= тесты должны быть написаны в классе;
= класс должен быть отнаследован от базового класса unittest.TestCase;
= имена всех функций, являющихся тестами, должны начинаться с ключевого слова test;
= внутри функций должны быть вызовы операторов сравнения (assertX) — именно они будут
  проверять наши полученные значения на соответствие заявленным.

Пример тестирования кода средствами unittest программы из модуля example.py

# исходный код в модуле u0_test.py
import unittest
from example import square_eq_solver

class SquareEqSolverTestCase(unittest.TestCase):
   def test_no_root(self):
       res = square_eq_solver(10, 0, 2)
       self.assertEqual(len(res), 0)

   def test_single_root(self):
       res = square_eq_solver(10, 0, 0)
       self.assertEqual(len(res), 1)
       self.assertEqual(res, [0])

   def test_multiple_root(self):
       res = square_eq_solver(2, 5, -3)
       self.assertEqual(len(res), 2)
       self.assertEqual(res, [0.5, -3])

Запускается данный код командой run, либо  командой
python.exe -m unittest u0_test.py
в командной строке


Результат

C:\PythonDrom\Tests_2022\test_11_10_2023>python.exe -m unittest uy0_test.py

----------------------------------------------------------------------
Ran 0 tests in 0.000s

OK

# код с ошибкой...
import unittest
from example import square_eq_solver

class SquareEqSolverTestCase(unittest.TestCase):
   def test_no_root(self):                  # метод "test_no_root"
       res = square_eq_solver(10, 0, 2)
       self.assertEqual(len(res), 0)

   def test_single_root(self):              # метод "test_single_root"
       res = square_eq_solver(10, 0, 0)
       self.assertEqual(len(res), 1)
       self.assertEqual(res, [0])

   def test_multiple_root(self):            # метод "test_multiple_root"
       res = square_eq_solver(2, 5, -3)
       self.assertEqual(len(res), 3)        # как такое может быть? ТРИ корня?
       self.assertEqual(res, [0.5, -3])

python.exe -m unittest u0_test.py

F..
======================================================================
FAIL: test_multiple_root (u0_test.SquareEqSolverTestCase.test_multiple_root)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\PythonDrom\Tests_2022\test_11_10_2023\u0_test.py", line 17, in test_multiple_root
    self.assertEqual(len(res), 3)
AssertionError: 2 != 3

----------------------------------------------------------------------
Ran 3 tests in 0.001s

FAILED (failures=1)

C:\PythonDrom\Tests_2022\test_11_10_2023>python.exe -m unittest u0_test.py
...
----------------------------------------------------------------------
Ran 3 tests in 0.000s

Так что если в каком-нибудь из тестов unittest найдёт ошибку, в том числе связанную с
корректностью вычислений, он о ней сообщит.

достоинтва unittest:
= Является частью стандартной библиотеки языка Python: не нужно устанавливать ничего дополнительно;
= Гибкая структура и условия запуска тестов. Для каждого теста можно назначить теги, в соответствии
  с которыми будем запускаться либо одна, либо другая группа тестов;
= Быстрая генерация отчетов о проведенном тестировании, как в формате plaintext, так и в формате XML.

недостатки unittest:
= Для проведения тестирования придётся написать достаточно большое количество кода
  (по сравнению с другими библиотеками);
= Из-за того, что разработчики вдохновлялись форматом библиотеки JUnit, названия основных функций
  написаны в стиле camelCase (например setUp и assertEqual) и это, конечно же, ОЧЕНЬ БОЛЬШОЙ
  недостаток;
= В языке python согласно рекомендациям pep8 должен использоваться формат названий snake_case
  (например set_up и assert_equal) (???).

pytest
pytest позволяет провести модульное тестирование (тестирование отдельных компонентов программы),
функциональное тестирование  (тестирование способности кода удовлетворять бизнес-требования (!!!)),
тестирование API (application programming interface) и многое другое.


Формат кода
Написание тестов здесь намного проще, нежели в unittest. Здесь нужно написать несколько функций,
удовлетворяющих следующим условиям:

- Название функции должно начинаться с ключевого слова test;
- Внутри функции должно проверяться логическое выражение при помощи оператора assert.

Warning! pytest запускается из КОМАНДНОЙ СТРОКИ!
Непосредственно из директории, в которой расположено приложение pytest.exe. То есть, сначала
надо определить, директорию (поиск файла можно выполнить средствами стандартного файлового
поиска чечрез меню "Пуск" либо воспользоваться средствами поиска в проводнике). Если приложение
pytest.exe было загружено, можно будет запустить pytest с указанием полного пути,
по которому может быть найден и запущен pytest. Подлежащий тестированию модуль также должен
содержать полный путь.

Всё это должно выглядеть как-то так:

C:\>C:\Users\anton\venv\Scripts\pytest.exe C:\PythonDrom\Tests_2022\test_11_10_2023\test_p2.py

Пример использования pytest для задачи поиска корней квадратного уравнения:
(файл C:\PythonDrom\Tests_2022\test_11_10_2023\test_p2.py)

def test_no_root():
   res = square_eq_solver(10, 0, 2)
   assert len(res) == 0

def test_single_root():
   res = square_eq_solver(10, 0, 0)
   assert len(res) == 1
   assert res == [0]

def test_multiple_root():
   res = square_eq_solver(2, 5, -3)
   assert len(res) == 3
   assert res == [0.5, -3]

Код, состоящий из тестируемых функций, запускается следующей командой

C:\>C:\Users\anton\venv\Scripts\pytest.exe C:\PythonDrom\Tests_2022\test_11_10_2023\test_pytest_go.py

Результ тестирования кода с помощью приложения pytest:

> pytest.exe example.py
======================= test session starts ======================
platform win32 -- Python 3.9.6, pytest-7.1.2, pluggy-1.0.0
rootdir: C:PyProjectstproger
collected 3 items

example.py ...                                              [100%]

======================== 3 passed in 0.03s =======================

В случае ошибки объём выводимой информации будет больше:

> pytest.exe example.py
======================= test session starts ======================
platform win32 -- Python 3.9.6, pytest-7.1.2, pluggy-1.0.0
rootdir: C:PyProjectstproger
collected 3 items

example.py ..F                                              [100%]

============================ FAILURES ============================
_______________________ test_multiple_root _______________________

    def test_multiple_root():
        res = square_eq_solver(2, 5, -3)
>       assert len(res) == 3
E       assert 2 == 3
E        +  where 2 = len([0.5, -3.0])

example.py:116: AssertionError
===================== short test summary info ====================
FAILED example.py::test_multiple_root - assert 2 == 3

=================== 1 failed, 2 passed in 0.10s ==================

Достоинства pytest:
= Позволяет писать компактные (по сравнению с unittest) наборы тестов;
= В случае возникновения ошибок выводится гораздо больше информации о них;
= Позволяет запускать тесты, написанные для других тестирующих систем;
= Имеет систему плагинов (и сотни этих самых плагинов), расширяющую возможности фреймворка.
  Примеры таких плагинов: pytest-cov, pytest-django, pytest-bdd;
= Позволяет запускать тесты в параллели (при помощи плагина pytest-xdist).

Недостатки pytest:
= pytest не входит в стандартную библиотеку языка Python. Поэтому его придётся устанавливать
  отдельно при помощи команды pip install pytest (один раз установили... Ну и что?);
= совместимость кода с другими фреймворками отсутствует. Так что, если пишется код под pytest,
  запустить его при помощи встроенного unittest не получится. Ну и что с того?

Если нужно базовое юнит-тестирование и известны фреймворки вида xUnit, тогда подойдёт unittest.
Если нужен фреймворк, позволяющий создавать краткие и изящные тесты, реализующие сложную логику
проверок, то pytest.

Оператор assert
Это инструмент отладки в python. Позволяет проверять правильность данных и условий в программе в
ходе её выполнения. Встроенная функция assert проверяет, является ли условие истинным.
Синтаксис оператора assert в python:

assert выражение1 [, выражение2]
выражение1: Это выражение, которое требуется проверить. Если оно возвращает True, то выполнение
            приложения продолжается. Если оно возвращает False, то возбуждается исключение AssertionError.
выражение2: Это необязательное выражение, которое представляет сообщение об ошибке, которое выводится,
            если выражение1 возвращает False.

Управление проверкой кода с помощью assert осуществляется во время разработки. assert позволяет
осуществлять проверку приложений в тестовом окружении (в том числе и с pytest).
В рабочих приложениях использование assert может быть опасным, поскольку его можно легко отключить
по всемы приложению, всего лишь с помощью ключа '-О' при при запуске приложения.
Поэтому рекомендуется использовать его только для проверки состояний, которые являются критичными
при выполнении первоначальных проверок.
Оператор assert можно применять для проверки ввода функции или для проверки её вывода.
В качестве примера использования assert проверка возвращаемых значений функции
(здравствуйте! какая встреча):

def test_single_root():
   res = square_eq_solver(10, 0, 0)
   assert len(res) == 1
   assert res == [0]

Или вот ещё один пример функции:

def divide(numerator, denominator):
    assert denominator != 0, "Делитель не может быть равен 0"
    return numerator / denominator

В этом примере, если функция divide() вызывается со значением denominator равным 0,
оператор assert генерирует AssertionError.

Использование assert при написании тестов:
Это одно из наиболее распространенных применений оператора assert. Во фреймворках для тестирования
(те самые unittest и pytest), assert использется для проверки того, что код корректно выполняется.
Примеры тестов с применением assert приводились выше.

Отключение assert
Как уже упоминалось, оператор assert можно отключить во всей программе, передав ключ -O при запуске python.
Вот пример такого запуска с отключением:

python -O x_script.py

В этом режиме все операторы assert в x_script.py будут проигнорированы. Это делает assert неподходящим
для обработки ошибок в работающем (выполняющемся в обычном режиме, а не в режиме разработки, тестирования и
отладки) коде.


pytest позволяет писать меньше однотипного кода, чем встроенный unittest, и может работать без тестовых
классов. Его базовые инструменты:

= Ключевое слово assert отвечает за результат тестирования. Если заданное после него условие истинно —
  тест пройден, если оно ложно — провален.
= Фикстуры — дополнительные функции, в которых можно задавать окружение тестов. Они могут использовать
  другие фикстуры, создавая целые иерархии.
= Метки — декораторы, которые позволяют корректировать поведение тестов: пропускать их, ожидать
  определённых результатов, передавать разные входные данные и так далее. Можно создавать свои
  пользовательские метки.

Post Scriptum
Тема тестирования сложна и обширна. К приведённому здесь коду есть вопросы.
Как минимум здесь отсутствует проверка на то, что вводимые данные обязательно должны быть
целыми числами. Если ввести любое другое число или строку, выполнение кода завершится с ошибкой.

